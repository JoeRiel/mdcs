;;; mds-output.el

;; Copyright (C) 2011 Joseph S. Riel, all rights reserved

;; Author:     Joseph S. Riel <jriel@maplesoft.com>
;; Created:    Jan 2011
;; Keywords:   maple, debugger
;;
;;; Commentary:

;; Code for the Maple Debugger Output buffer.

;;;

;;{{{ declarations

;; avoid compiler warnings

(declare-function mds--get-client-out-buf "mds")
(declare-function mds-showstat-view-dead-proc "mds-showstat")
(declare-function mds-windows-display-dead "mds-windows")

;;}}}
;;{{{ faces

(defface mds-args-face
  '((((class color) (background dark)) (:foreground "lawn green")))
  "Face for stack arguments."
  :group 'mds-faces)

(defface mds-entry-procname-face
  '((((class color) (background dark)) (:foreground "magenta1")))
  "Face for entry procnames (those printed on entering a procedure) in output buffer."
  :group 'mds-faces)

(defface mds-inactive-link-face
  '((((class color) (background dark)) (:foreground "cyan1")))
  "Face for inactive links in output buffer."
  :group 'mds-faces)

(defface mds-maple-error-face
  '((((class color) (background dark)) (:foreground "orange red")))
  "Face for Maple errors."
  :group 'mds-faces)

(defface mds-warning-face
  '((((class color) (background dark)) (:foreground "pink")))
  "Face for warning messages in output buffer."
  :group 'mds-faces)

(defface mds-prompt-face
  '((((class color) (background dark)) (:foreground "gray40")))
  "Face for prompt."
  :group 'mds-faces)
  
;;}}}
;;{{{ constants

(defconst mds-output-procname-re "\\([^ \t\n]+\\)\\(: \\|$\\)"
  "Regular expression that matches the procedure name generated by
the debugger commands 'stack' and 'where'.  The name is stored in 
the first group.")

(defconst mds-output-prompt-re "^(\\*\\([0-9]*\\)\\*)"
  "Regular expression to match prompt. Group one matches
the statement number; if empty then prompt corresponds
to user-input.")


;;}}}
;;{{{ variables

(defvar mds-client nil
  "Client associated with the output buffer.")

(make-variable-buffer-local 'mds-client)

;;}}}

;;{{{ Create and clear buffer

(defun mds-output-create-buffer (client)
  "Create and return an `mds-output-buffer' with client CLIENT."
  (let ((buf (generate-new-buffer "*mds-output*")))
    (with-current-buffer buf
      (setq mds-client client)
      (font-lock-mode 't))
    buf))

(defun mds-output-clear ()
  "Clear the debugger output buffer."
  (interactive)
  (let ((buf (mds--get-client-out-buf mds-client)))
    (when (bufferp buf)
      (with-current-buffer buf
	(delete-region (point-min) (point-max))))))

;;}}}

;;{{{ Text insertion

(defun mds-insert-and-font-lock (msg face &optional tag)
  "Insert string MSG into current buffer, at point, with font-lock FACE.
If optional TAG is present, insert it into the buffer before MSG."
  (and tag (mds-insert-tag tag))
  (let ((beg (point)))
    (insert msg)
    (mds-put-face beg (1- (point-max)) face)))

(defun mds-insert-tag (tag)
  "Insert TAG as string with colon in the current buffer, at point."
  (let ((beg (point)))
    (insert (format "<%s>" (prin1-to-string tag)))
    (mds-put-face beg (point) 'font-lock-string-face)
    (insert ": ")))

(defun mds-put-face (beg end face)
  "Put FACE as a `font-lock-fact' text property on text between BEG and END."
  (put-text-property beg end 'font-lock-face face))

(defun mds-output-append-input (buf msg)
  "Append string MSG and newline to the output buffer BUF.
MSG is considered external input from a user, so the state-number
in the prompt is cleared. The purpose is to prevent `mds-output-goto-line'
from going to a statement that does not correspond to procedure evaluation."
  (with-current-buffer buf
    (beginning-of-line)
    (if (looking-at mds-output-prompt-re)
	(replace-match "" 'fixedcase 'literal nil 1))
    (goto-char (point-max))
    (insert msg "\n")))

;;}}}

;;{{{ mds-output-display

(defun mds-output-display (buf msg &optional tag)
  "Display MSG in BUF, which is assumed an output buffer.
Optional TAG identifies the message type."
  (unless (string= msg "")
    (display-buffer buf)
    (with-selected-window (get-buffer-window buf)
      (with-current-buffer buf
	(goto-char (point-max))
	(if (not tag)
	    (insert msg)
	  (let ((beg (point)))
	    (cond
	     ((stringp tag)
	      ;; string tag (temporary)
	      (mds-insert-tag tag) 
	      (insert msg))
	     
	     ((eq tag 'cmd)
	      ;; Command
	      (insert msg "\n"))
	     
	     ((eq tag 'prompt)
	      ;; Insert prompt, with statement number (msg) embedded.
	      ;; Goto to beginning of line and replace line, that way
	      ;; an existing prompt is replaced.
	      (beginning-of-line)
	      (setq beg (point))
	      (insert "(*" msg "*) ")
	      (mds-put-face beg (point) 'mds-prompt-face)
	      ;; (mds-output-hyperlink-prompt (+ 2 beg) (- (point) 3))
	      ;; (mds-output-hyperlink-prompt beg (1- (point)))
	      (delete-region (point) (line-end-position)))

	     ((eq tag 'output)
	      (insert msg))

	     ((eq tag 'procname)
	      (insert msg)
	      (make-text-button beg (point) :type 'mds-output-view-proc)
	      (insert "\n"))
	     
	     ((eq tag 'stack)
	      ;; stack
	      (insert msg)
	      (if (string= msg "TopLevel\n")
		  (mds-put-face beg (point) 'mds-inactive-link-face)
		(make-text-button beg (1- (point)) :type 'mds-output-goto-proc)))

	     ((eq tag 'where)
	      (insert msg)
	      (goto-char beg)
	      (let ((toplev (looking-at "TopLevel")))
		(unless (re-search-forward ":\\( \\|$\\)" nil 't)
		  (error "no delimiter"))
		(if toplev
		    (mds-put-face beg (- (point) 2) 'mds-inactive-link-face)
		  (make-text-button beg (- (point) 2) :type 'mds-output-goto-proc))))

	     ((eq tag 'args)
	      ;; args
	      (mds-insert-and-font-lock msg 'mds-args-face tag))

	     ((eq tag 'printf)
	      ;; insert msg, but no newline; this could screw-up format
	      ;; but need to trust user here. 
	      (insert msg))

	     ((eq tag 'warn)
	      ;; warning
	      (mds-insert-and-font-lock msg 'mds-warning-face tag))

	     ((eq tag 'maple-err)
	      ;; maple error
	      (mds-insert-and-font-lock msg 'mds-maple-error-face tag))
	     
	     ((eq tag 'parser-err) 
	      ;; maple parser error
	      (mds-insert-and-font-lock msg 'mds-maple-error-face tag))

	     ((and tag (symbolp tag))
	      ;; unknown tag
	      (mds-insert-tag tag) (setq beg (point))
	      (insert msg))
	     )))
	(recenter -1)))))

;;}}}

;;{{{ Buttons
;;{{{ (*) Button for procname

;; The following two buttons type could functionally
;; be replaced by one, but the button type
;; is used to distinguish them, so different names
;; are required (there is probably a better way).

;; define button used to hyperlink entry procname
(define-button-type 'mds-output-view-proc
  'help-echo "Open procedure"
  'action 'mds-output-view-proc
  'follow-link t
  'face 'mds-entry-procname-face)

;; define button used to hyperlink showstack/where procnames
(define-button-type 'mds-output-goto-proc
  'help-echo "Open procedure and goto statement"
  'action 'mds-output-view-proc
  'follow-link t
  'face 'link)

(defun mds-output-view-proc (button)
  "Search at start of line for the Maple procedure name and
optional statement (call) from the output generated by the
'stack' and 'where' debugger commands."
  (save-excursion
    (beginning-of-line)
    (unless (looking-at "TopLevel")
      (looking-at mds-output-procname-re)
      (mds-output-display-proc (match-string-no-properties 1)
			       ;; The following is non-nil when this is the
			       ;; output of where, which includes the entire
			       ;; statement.  There is a problem.  If the
			       ;; statement is printed on multiple lines, say a
			       ;; conditional, then the showstat-buffer will
			       ;; include line numbers that don't appear in the
			       ;; actual statement.  We could attempt a partial
			       ;; match.  
			       (buffer-substring-no-properties (match-end 0) (line-end-position))))))

;;}}}
;;}}}

;;{{{ Goto Source Line

(defun mds-output-goto-source-line (pos)
  "Goto the line of source corresponding to the output at
position POS in the output buffer.  This works by finding
the closest prompt, extracting the line number, then finding
the previous procedure name.  To make this less likely to fail,
evaluating expressions should remove (or tag) the corresponding
prompt so that it is later not matched."
  (interactive "d")
  (save-excursion
    (goto-char pos)
    (end-of-line)
    (if (re-search-backward mds-output-prompt-re nil 'move)
	(let ((state (match-string-no-properties 1)))
	  (if (string= state "")
	      (message "position does not correspond to output from procedure")
	    (let ((procname (mds-output-get-enclosing-procname)))
	      (if procname
		  (mds-output-display-proc procname "0" state)
		(beep)
		(message "no procedure found in buffer"))))))))

(defun mds-output-display-proc (procname statement &optional state)
  "Display procedure PROCNAME in the dead buffer.  Put arrow at STATEMENT.
If STATEMENT is the string \"0\", then use STATE." ;; FIXME may be a bad choice
  (when procname
    (mds-showstat-view-dead-proc procname statement state)
    (mds-windows-display-dead mds-client)))
  

(defun mds-output-get-enclosing-procname ()
  "Search upwards from point to find the first embedded procname
and return it.  If none is found, return nil, and leave point
at beginning of buffer."
  (let (fnd)
    (while (and
	    (re-search-backward "^\\([A-Za-z0-9/:_`-]+\\)$" nil 'move)
	    (not (setq fnd (mds-output-procname-p (point))))))
    (if fnd (match-string-no-properties 0))))

;;}}}

(provide 'mds-output)

;; mds-output.el ends here
