-*- org -*-

* Short Term

** TODO Decide how the output buffer should look.  

   * Should it mimic what is done in mdb, that is, when an input is
     entered by user (using 'e' or '.'), it echos the command, then
     displays the output.

   * Alternately, should it show a prompt and allow the user to enter
     commands there?  Essentially mimicing the tty debugger interface,
     but with the current state suppressed. That seems more difficult
     to implement but potentially more useful.  I would still want the
     ability to evaluate stuff from the showstat buffer and have it
     appear in the output buffer, otherwise a lot of buffer changing
     would be required.

   * It would be useful to associate the output lines with the inputs
     (in showstat) that generated them.  That is only partially
     doable.  Suppose we are at statement 3, with a breakpoint
     at statement 10.  Executing "continue" moves the cursor
     to statement 10 and prints last generated output, which could
     be from anywhere.  That could be indicated with a display
     that looks like

     [[int:-ModuleApply]]
     args := a
           , b
           , c:
     (*  [[3]] *) cont
     some output ...
     (* [[10]] *) 

     The lines have buttons; clicking on them moves the cursor to that
     statement.  The relevant procedure is determined by se


** DONE Insert procedure name in mode-line of showstat buffer
   CLOSED: [2011-06-04 Sat 21:31]

   * Wrote [[file:lisp/mds-showstat.el::defun%20mds%20showstat%20set%20mode%20line%20proc][mds-showstat-set-mode-line]] to do this.

   * There is a snag; it needs the name of the procedure.
     That is supposed to be stored in the `mds-showstat-procname'
     variable, however, when the dead buffer is updated via
     a call to `mds-eval-and-prettyprint', procname is never
     directly available.  Two possible fixes:

     1. Extract the name from the buffer after printing.
     2. Implement a protocol for returning the procedure name.

   * The latter seems better, but is a bit of work for a one-off fix.
     However, it could be useful for other enhancements.
     For the nonce I'll go with the former.

   * Method 1 is now implemented. 

** TODO The first field in the mode-line always shows "no-proces".
   
   * The simple fix is to just delete it.  That will also open up more
     room, which will help on the laptop with a split screen.

   * A field that needs to be added to the mode-line is the 
     a label identifying the user/job.  


** TODO Implement a window manager

   * Something simple that keeps the related windows of one
     client together.

   * Current plan, for "single thread" debugging, is to display two
     windows, showstat-lve and output.  Showstat-dead, when active,
     will replace output since those two rarely need to be seen
     concurrently, I think.  New data to the output buffer will cause
     it to pop forward.

   * Hmm.  That doesn't quite work (implemented in windows-manager
     branch).  The problem occurs with the call stack; it generally
     displays multiple procedures.  If clicking on one of the
     hyperlinks cause the dead buffer to replace the output buffer,
     then we have to manually bring the output buffer forward to click
     on another.  A better strategy, by default, is to have the dead
     buffer and the live buffer share the same window.  

* Long Term
 
** TODO Handle exports of unnamed modules.
   1. The problem occurs when a module is assigned as
      M := module() ... end module.  Unless the module is
      saved and loaded from a library, the module technically
      does not have a name.  Consequently, showstat does not
      display the module name when an export is printed.
      This makes it impossible for the debugger to operate on the 
      correct procedure.
   2. One solution is to modify 'debugger' so that the current
      procedure name is stored in a global variable.  That, however,
      doesn't solve the problem if we open an inactive procedure,
      say by using the 'where' procedure.   
   3. Another solution, with the same limitation, but advantageous
      in that it does not require a change to 'debugger', is to
      elide the procedure name passed to showstat when inside
      the active procedure.
   4. The practical workaround is to name modules.  That does not
      work with constructed modules, that is, those returned by
      a procedure.  Do they have to be unnamed?
      
