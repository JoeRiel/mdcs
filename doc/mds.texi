\input texinfo
@c %***start of header
@setfilename mds
@settitle The Maple Debugger Server Manual

@set VERSION 2.3.0
@set DATE June 2011

@dircategory Emacs
@direntry
* mds: (mds).      Maple Debugger Server
@end direntry

@c Version and Contact Info
@c @set MAINTAINERSITE @uref{http://orgmode.org,maintainers webpage}
@set AUTHOR Joe Riel
@set MAINTAINER Joe Riel
@set MAINTAINEREMAIL @email{jriel at san dot rr dot com}
@set MAINTAINERCONTACT @uref{mailto:jriel at maplesoft dot com,contact the maintainer}
@c %**end of header
@finalout

@copying
MDS is an Emacs package that implements a Maple Debugger Server.
It is part of the Maple Debugger Client/Server Architecture. 
Maple is a computer algebra system from @w{Waterloo Maple Inc}.

This manual is for MDS version @value{VERSION}.

Copyright @copyright{} 2011, Joseph S. Riel

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License.''
@end quotation
@end copying

@titlepage
@title The Maple Debugger Server Manual

@subtitle Release @value{VERSION}
@author by Joseph Riel

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top Maple Debugger Server Manual

@insertcopying
@end ifnottex

@menu
* Introduction::                Installing and configuring.
* Launching MDS::               Starting and stopping the server.
* Showstat Buffer::             Stepping through interpreted code.
* LineInfo Buffer::             Stepping through source code.
* Output Buffer::               Maple output.
* Debugging Tips::              Tips and technique.

Indices

* Key Index::                   Key bindings and where they are described.
* Function Index::              Functions mentioned in the manual.
* Variable Index::              Variables mentioned in the manual.
* Concept Index::               Concepts and features.

License

* GNU Free Documentation License::  Copying this manual.

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Summary::                     Summary of what MDS does.
* Requirements::                What is needed to run MDS.
* Installation::                How to install MDS.
* Configuration::               How to configure MDS.
* Customization::               Customize MDS variables.
* Feedback::                    Bug reports, ideas, etc.

Configuration

* Emacs::                       Configuring @file{.emacs}.

Showstat Buffer

* Live Showstat Buffer::        Stepping through interpreted code.
* Dead Showstat Buffer::        Viewing other procedures.
* Showstat Mode::               Debugger commands.

Showstat Mode

* Execution::                   Executing procedure statements.
* Status::                      Determining debugger status.
* Breakpoints::                 Setting and clearing breakpoints.
* Watchpoints::                 Setting and clearing watchpoints.
* Evaluation::                  Evaluating expressions.
* Miscellaneous::               Miscellaneous commands.
* Monitoring::                  Display selected expressions at each step.
* Patching::                    Live patching Maple procedures.
* Help::                        Getting help.

LineInfo Buffer

* Accessing LineInfo::          Creating the line-info data.
* LineInfo Mode::               Available commands.
* LineInfo Caveats::            Limitations.

LineInfo Caveats

* Preprocessor macros::         Avoid multi-statement macros.
* for-less do-loops::           A glitch with while loops.
* use statement::               Use @code{uses}.
* Declaration Self-Assignment::  Avoid this undocumented feature.

Output Buffer

* Output buffer commands::      

Debugging Tips

* Set breakpoint in calling procedure::  Locating a bug.
* Locate source of unexpected result::  Finding where an expression originates.
* Assign a variable::           Returning intermediate results to Maple.
* Save a local result::         Saving intermediate results to a file.

@end detailmenu
@end menu

@node Introduction, Launching MDS, Top, Top
@chapter Introduction
@cindex introduction

@menu
* Summary::                     Summary of what MDS does.
* Requirements::                What is needed to run MDS.
* Installation::                How to install MDS.
* Configuration::               How to configure MDS.
* Customization::               Customize MDS variables.
* Feedback::                    Bug reports, ideas, etc.
@end menu



@node Summary, Requirements, Introduction, Introduction
@comment  node-name,  next,  previous,  up
@section Summary
@cindex summary

MDS is an Emacs package that implements a @emph{Maple Debugger Server}.  
It is part of the @emph{Maple Debugger Client/Server} architecture.
This manual describes the installation, configuration, and usage
of the server.  For help with the client, see the Maple help pages
for @command{mdc}.@footnote{In Maple, type @samp{?mdc}}

The client/server architecture provides several benefits:

@itemize @bullet
@item
A common, full-featured, debugger interface that can be used whether
running Maple from the GUI, the command-line, or from a script.
@item
Remote debugging---the client (Maple) can be run on one machine, the
server on another. Communication is via standard TCP.
@item
Concurrent debugging---multiple Maple processes can be debugged
simultaneously. This permits interactively comparing the actions of
different versions of code, or comparing code run on machines with
different operating systems. It also permits independently or
synchronously stepping through separate processes in a @b{Grid}
application.
@end itemize

The user interface to the debugger, which is provided 
by MDS, has the following features.

@itemize @bullet
@item
The procedure being debugged is displayed in a buffer
with font-locking to highlight syntactic elements.
@item
Executing the code advances an @emph{overlay-arrow} 
that points to the next statement to be executed.
@item
The output of executed statements and evaluated expressions
are displayed in a separate window.  
These are printed in 1-D format so that they 
can be saved and reused as Maple input. 
@item
As lines of code are executed, they are echoed in the output
window; @pxref{Output Buffer}.
The result provides a visual trace of all the code
that has been executed.  Clicking in the output window
opens a third window that displays the procedure and
statement that generated the selected output.
@item
Expressions can be directly evaluated and displayed in a nice format.
For example, a record can be displayed as a vertical list of equations
with field name on the left and the entry on the right.
@item
The common debugging commands, 
@strong{next}, @strong{into}, @strong{step}, etc.,
are bound to keystrokes (@kbd{n}, @kbd{i}, @kbd{s}, etc.).
@xref{Execution}.
@item 
Breakpoints can be set or cleared directly in the buffer.
@item
A trace mode permits rapidly tracing through instrumented procedures.
That, coupled with the ability to jump from the output to
the corresponding statement in the code, facilitates debugging.
@xref{tracing}.
@item
Debugged procedures can be @emph{live-patched}, that is, modified in-place.  
This permits testing changes without access to the full source code.
@xref{Patching}.
@end itemize

@node Requirements, Installation, Summary, Introduction
@comment  node-name,  next,  previous,  up
@section Requirements
@cindex requirements


@table @r
@item GNU Emacs 23.1+
MDS should work with earlier versions of Emacs but has not been tested.
@item Maple 14+  
MDS should work with earlier versions of Maple but has not been tested.
Some features, such as the line-info buffer, see @ref{LineInfo Buffer},
are only available on Maple 16+.
@item MapleV mode
An Emacs mode for developing Maple source code.
If you use Maple with Emacs, you definitely want to have this,
regardless whether you use MDS.
The latest version is available at
@url{https://github.com/JoeRiel/maplev}.
Debian and Ubuntu provide a version with the @file{emacs-goodies-el}
package, but it is dated.
@end table


@node Installation, Configuration, Requirements, Introduction
@comment  node-name,  next,  previous,  up
@section Installation
@cindex installation
@cindex README
@cindex README-installer

Directions for installing MDS are in a text file included 
with the distribution, named either 
@file{README} or @file{README-installer}.

@node Configuration, Customization, Installation, Introduction
@comment  node-name,  next,  previous,  up
@section Configuration
@cindex configuration

This section describes how to configure your system
to run MDS.  


@menu
* Emacs::                       Configuring @file{.emacs}.
@end menu

@node Emacs,  , Configuration, Configuration
@comment  node-name,  next,  previous,  up
@subsection Emacs
@cindex emacs
@cindex .emacs

To permit @kbd{M-x mds} to start (and restart) MDS, 
add the following lines, appropriately modified,
to your @file{.emacs} file:

@example
;; add ~/.emacs.d/maple to Emacs load-path
(setq load-path (cons (format "%s/.emacs.d/maple" (getenv "HOME")) load-path))
(autoload 'maplev-mode "maplev" "Maple editing mode" t)
(autoload 'mds "mds" "Restart the Maple Debugger Server" t)
@end example

Consider binding global keys to the commands
@command{mds-windows-cycle-clients} and
@command{mds-windows-cycle-groups}.  

The former is for cycling through the list of all clients, the latter
for cycling through groups of clients.  Groups are formed from clients
with labels that share a common basename. This is used with the
@command{mdc[Grid]}@footnote{Type @samp{?mdc[Grid]} in Maple for more
information.} commands in the Maple client.  For example, to bind these
commands to the @key{f12} and @key{CTRL}-@key{f12} keystrokes, do

@example
(global-set-key [f12] 'mds-windows-cycle-clients)
(global-set-key [C-f12] 'mds-windows-cycle-groups)
@end example

If you use MDS frequently, you may want to start 
the server in your @file{.emacs} file.  Do this 
by adding the command

@example
(mds) ; launch Maple Debugger Server
@end example

@node Customization, Feedback, Configuration, Introduction
@comment  node-name,  next,  previous,  up
@section Customization
@cindex customization

MDS has a number of variables that can be customized.
To access them load MDS (@code{M-x mds}) then run 
@code{M-x customize-group} and enter @code{mds} or
@code{mds-faces}.

The most useful customizations are the following:

@table @asis

@vindex mds-get-focus-function
@item @command{mds-get-focus-function}
A function that calls the window manager to transfer
focus to Emacs.  This is called when a Maple client begins debugging.
The default is nil unless the command @command{wmctrl}
is available, then it is set to @code{mds-windows-get-focus-wmctrl}.
The nil value means that focus will not automatically be
transferred to Emacs.

Note that transfer of focus may only occur when the debugger is
@emph{first} entered.  Upon exiting and reentering the debugger, this
function is not called, though it should be.  That is due to a
limitation of the Maple debugger kernel; it does not provide an
indication that debugging has either begun or ended.

@vindex mds-port
@item @code{mds-port}
An integer that is the TCP port number used for communication.
The default is 10000.

@vindex mds-keep-dead-clients
@item @code{mds-keep-dead-clients}
A boolean variable that when non-nil prevents the buffers
associated with a client from being removed when the client disconnects.
Setting this to non-nil can be useful when tracing a command
that causes the Maple kernel to disconnect.
@xref{tracing}.
The default value is nil.

@vindex mds-show-args-flag
@findex mds-toggle-show-args
@item @command{mds-show-args-flag}
A boolean variable that when non-nil causes the arguments
to a procedure to be automatically displayed when first
entering the procedure.  The default displays arguments.
The command @command{mds-toggle-show-args} toggles this flag.
@findex mds-toggle-show-args

@vindex mds-stop-trace-at-trapped-error-flag
@findex mds-toggle-stop-trace-at-trapped-error
@item @code{mds-stop-trace-at-trapped-error-flag}
A boolean variable that, when non-nil, causes tracing to stop when an error
is trapped.  This is only effective if error-trapping is enabled.  
@xref{tracing}.  The default is nil.  
The command @code{mds-toggle-stop-trace-at-trapped-error} toggles this flag.
@findex mds-toggle-stop-trace-at-trapped-error

@vindex mds-track-input-flag
@findex mds-toggle-track-input
@item @code{mds-track-input-flag}
A boolean variable that, when non-nil, causes the input line of
the procedure being debugged to be echoed to the output buffer
when the line is executed.  The default echos the line.
The command @code{mds-toggle-track-input} toggles this flag.
@findex mds-toggle-track-input

@vindex mds-truncate-lines-flag
@item @code{mds-truncate-lines-flag}
A boolean variable that, when non-nil, causes lines in the showstat and 
output windows to be truncated at the right edge of the screen 
rather than wrapping.  The default truncates lines.
The command @command{mds-toggle-truncate-lines} toggles this flag.
@findex mds-toggle-truncate-lines

@vindex mds-wait-until-ready-flag
@item @code{mds-wait-until-ready-flag}
A boolean variable that, when non-nil, forces the debugger to wait until
a prompt has been received to send the user's response.  Setting it
to nil allows pipe-lining responses, but prevents a notification when
the debugger has exited.  The default is to wait for a prompt.
This flag is toggled with the command @command{mds-toggle-wait-until-ready}.
@findex mds-toggle-wait-until-ready

@vindex mds-wm-side-by-side
@item @code{mds-wm-side-by-side}
A boolean variable that, when non-nil, causes the @b{live-showstat}
and @b{output} windows to appear side-by-side when displayed
in a single client view.  That is the default.  When nil
the windows appear one above the other.

@vindex mds-wm-ss-fractional-size
@item @code{mds-wm-ss-fractional-size}
Specifies the fractional size of the showstat-live window to the full frame size.
Width is used when @code{mds-wm-side-by-side} is non-nil, otherwise height is used.  
If nil, the window is set to half the frame size.

@end table





@node Feedback,  , Customization, Introduction
@section Feedback
@cindex feedback

If you find problems with MDS, or if you have questions,
comments, or ideas, please mail them to Joe Riel, @email{jriel@@maplesoft.com}.

@findex mds-version
For bug reports, please provide as much information as possible,
including the version information of Emacs (@kbd{C-h v emacs-version}),
MDS, (@kbd{M-x mds-version}), and Maple (@code{version()}).


@node Launching MDS, Showstat Buffer, Introduction, Top
@chapter Launching MDS
@cindex launching mds
@cindex starting mds
@cindex stopping mds

@findex mds
The @kbd{M-x mds} command starts the Maple Debugger Server.  If the
server is already running, it is restarted, which disconnects all
clients.  

When a client connects, two buffers are opened,
the @b{showstat buffer} (@pxref{Showstat Buffer}),
which displays the current procedure,
and 
the @b{debugger output buffer}, 
which displays Maple output during debugging.

@findex mds-stop
To stop the server, use @kbd{M-x mds-stop}.

@node Showstat Buffer, LineInfo Buffer, Launching MDS, Top
@chapter Showstat Buffer
@cindex showstat buffer

Each client has two showstat buffers, named @verb{|*showstat live*|} and
@verb{|*showstat dead*|}, that are used to display Maple procedures
in @emph{showstat format}, that is, with the statements numbered.
Both use @code{mds-showstat-mode}, though some commands are handled
differently.

@menu
* Live Showstat Buffer::        Stepping through interpreted code.
* Dead Showstat Buffer::        Viewing other procedures.
* Showstat Mode::               Debugger commands.
@end menu

@node Live Showstat Buffer, Dead Showstat Buffer, Showstat Buffer, Showstat Buffer
@section Live Showstat Buffer
@cindex live showstat buffer

The live showstat buffer becomes active when an instrumented Maple procedure activates 
a breakpoint or watchpoint.
The buffer displays the output of the Maple @code{showstat} command, that is,
the current procedure being debugged.
Maple statements are numbered and Maple keywords and syntactic elements are highlighted.
The Maple statement to be executed next is indicated by an @emph{overlay-arrow} in the left margin.
Breakpoints are marked by asterisks to the right of the statement numbers.

The following figure shows a typical display.
The overlay-arrow @samp{=>} is at the first statement of the procedure,
which is also marked with an asterisk indicating that there is a breakpoint here.

@example
@anchor{fibonacci}
@iftex
@strong{fibonacci} := @strong{proc}(i::integer) 
=> 1*  @strong{if} i < 1 @strong{then}
   2     0
       @strong{elif} i = 1 @strong{then}
   3     1
       @strong{else}
   4     procname(i-2)+procname(i-1)
       @strong{end if}
@strong{end proc}
@end iftex
@ifinfo
fibonacci := proc(i::integer) 
=> 1*  if i < 1 then
   2     0
       elif i = 1 then
   3     1
       else
   4     procname(i-2)+procname(i-1)
       end if
end proc
@end ifinfo
@end example

@node Dead Showstat Buffer, Showstat Mode, Live Showstat Buffer, Showstat Buffer
@section Dead Showstat Buffer
@cindex dead showstat buffer

The dead showstat buffer looks the same as the live buffer.
It is used for displaying inactive procedures.  It is normally
not displayed until a request is made to display an inactive
procedure.

Currently typing execution keys in the dead showstat buffer
function the same as if typed in the live buffer to advance.  This
will most likely be changed.
 


@node Showstat Mode,  , Dead Showstat Buffer, Showstat Buffer
@section Showstat Mode
@cindex showstat mode

@code{mds-showstat-mode} binds keys to the common debugging commands. 
It also provides commands that are not available in the Maple debugger.
The following sections describe these bindings and commands.
They are grouped according to function.

@menu
* Execution::                   Executing procedure statements.
* Status::                      Determining debugger status.
* Breakpoints::                 Setting and clearing breakpoints.
* Watchpoints::                 Setting and clearing watchpoints.
* Evaluation::                  Evaluating expressions.
* Miscellaneous::               Miscellaneous commands.
* Monitoring::                  Display selected expressions at each step.
* Patching::                    Live patching Maple procedures.
* Help::                        Getting help.
@end menu

@node Execution, Status, Showstat Mode, Showstat Mode
@subsection Execution
@cindex execution

MDS supports all the Maple debugger commands for executing the statements of
a procedure and includes some commands that are not part of the standard 
debugger.  These commands are bound to single keystrokes in the Showstat buffer.
Output from these commands is written to the @emph{debugger output buffer};
@pxref{Output Buffer}.

When any of these commands are executed, the cursor moves forward one character
and, if the flavor of Emacs supports it, the cursor changes to a hollow box.
This indicates that it is waiting for Maple to respond (for most commands this
change is too short to be noticeable).
When Maple responds the cursor moves to the next statement to be executed 
and the cursor returns to a filled box.

The cursor types can be customized via
the variables @code{mds-cursor-waiting} and @code{mds-cursor-ready}.
@vindex mds-cursor-waiting
@vindex mds-cursor-ready

The following table describes each of the execution commands.

@table @asis

@kindex c
@findex mds-cont
@item c (@command{mds-cont})
Continue: run until the next breakpoint or watchpoint, or until the program terminates.

@kindex g
@kindex @kbd{C-u g}
@findex mds-goto-procname
@anchor{mds-goto-procname}
@item g (@command{mds-goto-procname})
Goto a procedure, that is, skip until the selected procedure is active.
The name of the procedure is surmised from the code at point; if no function
call if found, the name is queried in the minibuffer.  If called
with an argument, @kbd{C-u g}, the procedure name is queried in the
minibuffer, the default is taken from the code at point.  This feature
is built on the skipping mechanism; it does not use breakpoints.  It
relies on string-matching to determine whether the selected procedure has
been entered, so can sometimes give surprising results.

This command saves a @strong{goback} point at the statement where
it was called; @pxref{mds-goback-save}.

@kindex h
@findex mds-here
@anchor{mds-here}
@item h (@command{mds-here})
Execute code until the statement at which the command was executed
is reached.  This is similar to setting a breakpoint at the
statement, then continuing, however, it uses the skipping mechanism
rather than breakpoints.  If passed an optional numeric prefix, e.g.,
@kbd{C-u 5 h}, then skipping continues until the statement has been
reached that many times.

If executed at a location without a statement number,
say, at an @code{else}, the preceding statement number is used
as the target.

It can be called from the dead showstat buffer (@pxref{Dead Showstat Buffer});
execution skips to the statement in the corresponding procedure.

This command saves a @strong{goback} point at the statement where
it was called; @pxref{mds-goback-save}.

@kindex i
@findex mds-into
@item i (@command{mds-into})
Into: halfway between @command{next} (@kbd{n}) and @command{step}
(@kbd{s}).  Executes the next statement.  Execution stops before the
following statement within the current function, regardless of whether
it is at the current nesting level or in the body of a control
structure. Execution does not stop in a called function.

@kindex n
@findex mds-next
@item n (@command{mds-next})
Next: execute the next statement.  If the statement
is a control structure (for example, @code{if} or @code{for}), it is
executed in its entirety before execution stops again. Likewise, if
the statement contains function calls, these are executed in their
entirety.  After executing the statement, control returns to the
Debugger as though a breakpoint had been set.

@kindex o
@findex mds-outfrom
@item o (@command{mds-outfrom})
Outfrom: execute until the current statement sequence has finished, or
until a breakpoint or watchpoint is encountered. If this command is
executed while stopped in a loop, execution continues until just
before the first statement to be executed after the closing @code{end do}.
Note that if the same breakpoint that caused execution to stop in
the loop is encountered again in a subsequent iteration of the loop,
execution will stop again. If this command is executed while
stopped in the body of an @code{if} statement, execution continues until just
before the first statement to be executed after the closing @code{end if}.

@kindex q
@findex mds-quit
@item q (@command{mds-quit})
Quit: terminate debugging.

@kindex r
@findex mds-return
@item r (@command{mds-return})
Return: execute statements until the first statement to be executed
after the currently executing procedure returns.

@kindex s
@findex mds-step
@item s (@command{mds-step})
Step: execute the next statement at any level.  Execution stops before
the following statement, regardless of whether it is at the current
nesting level, in the body of a control structure (for example,
@code{if}), or in a called function.

@kindex S
@findex mds-skip
@item S (@command{mds-skip})
Skip forward until the predicate assigned by the @code{skip_until}
option to @code{mdc} is true.

@kindex t
@findex mds-select-trace
@vindex mds-stop-trace-at-trapped-error-flag
@cindex tracing
@anchor{tracing}
@item t (@command{mds-select-trace})
Select the tracing mode.  The selected tracing mode, 
@strong{none}, @strong{cont}, @strong{next}, @strong{into}, @strong{step}, or @strong{_skip},
determines where the debugger temporarily halts and what output 
is displayed in the output buffer. The selected mode is equivalent 
to continually executing the corresponding debugging command
(the _skip command is equivalent to calling @command{mds-skip}).

After selecting a tracing mode, tracing begins with the next command
that executes a statement.  Statements are then automatically executed
until the client exits or, if @code{mds-stop-trace-at-trapped-error-flag} is
non-nil, an error is trapped.  At that point, the tracing mode may be
manually disabled by selecting the @strong{disabled} mode.
If Maple has exited, reissuing the original Maple
command causes the debugger to recommence, at which time the
hyperlinks in the output buffer become operational and permit quickly
moving to places of interest.

@kindex @key{SPACE}
@findex mds-send-last-command
@item @key{SPACE} (@command{mds-send-last-command})
Re-execute the last command that executed a program statement.
The saved commands are
@command{cont},
@command{into},
@command{next},
@command{outfrom},
@command{return},
@command{step},
and
@command{return}.

@kindex @kbd{C-c C-c}
@findex mds-kill-maple
@item C-c C-c (@command{mds-kill-maple})
Kill the maple process.
This can be used to stop a runaway Maple computation (say an infinite loop).
@strong{This currently is not implemented.}

@end table

@node Status, Breakpoints, Execution, Showstat Mode
@subsection Status
@cindex status

MDS supports the following debugger commands for querying the status
of the debugger.

@table @asis

@kindex k
@findex mds-showstack
@item k (@command{mds-showstack})
Showstack: display an abbreviated form of the calling stack.
Only the names of the procedures are shown.  The name of the current
procedure is not shown.  Each name is an active link.  Clicking on a link
(mouse-1) opens the procedure in the @strong{showstat dead} buffer.

@kindex K
@findex mds-where
@item K (@command{mds-where})
Where: display the calling stack. 
The latest entry is shown last.
For each entry in the stack,
the name of the calling procedure and the current statement within it are shown,
followed on the next line by the list of arguments passed to corresponding procedure.
An optional prefix argument can be passed; it specifies the number of levels to display.
For example @kbd{C-u 2 K} displays the topmost (most recent) two entries.

The procedure names are active links.  Clicking on a link opens the
procedure in the @strong{showstat dead} buffer, at the calling line.  
Breakpoints can be set in the opened procedure.
Use @command{M-x mds-goto-current-state} (@kbd{l})
to return to the current procedure.

@kindex p
@findex mds-showstop
@item p (@command{mds-showstop})
Showstop: display a list of all procedures containing breakpoints, all
watchpoints, and all error watchpoints.

@kindex x
@findex mds-showexception
@item x (@command{mds-showexception})
Showexception: display the value of @code{lastexception}.
The output is formatted;
to see the raw exception, use @kbd{C-u x}.

@kindex X
@findex mds-showerror
@item X (@command{mds-showerror})
Showerror: display the value of @code{lasterror}.
The output is formatted;
to see the raw exception, use @kbd{C-u X}.


@end table


@node Breakpoints, Watchpoints, Status, Showstat Mode
@subsection Breakpoints
@cindex breakpoints

MDS can set and clear breakpoints, watchpoints, and error watchpoints.
Breakpoints can be set and cleared as is done in the Maple debugger, that is, 
by evaluating the expression @code{stopat <statement-number>}, 
however, the more convenient way is to move the cursor to the statement 
and type @kbd{b} or @kbd{u}, respectively.
A statement with a breakpoint has an asterisk to the right of the statement number;
@pxref{fibonacci,,the fibonacci listing}.

@table @asis

@kindex b
@findex mds-breakpoint
@item b (@command{mds-breakpoint})
Stopat:  Set a breakpoint at the start of the statement at the cursor.
An asterisk appears to the right of the statement number.
The debugger is halted each time it reaches the statement.

@kindex B
@findex mds-breakpoint-cond
@item B (@command{mds-breakpoint-cond})
Stopat-cond:  Set a conditional breakpoint at the start of the statement at the cursor.
The condition is entered in the mini-buffer.  It must be a Maple boolean expression.
A question mark appears to the right of the statement number.
The debugger is halted each time it reaches the statement and the condition evaluates to true.

@kindex G
@findex mds-goback-save
@anchor{mds-goback-save}
@item G (@command{mds-goback-save})
Save the statement at point as a @strong{goback} point.  You may return
to a goback point, after exiting the debugger, by executing
@code{mdc(goback)} in the Maple client and then entering the debugger
by executing the debugged Maple command.

If @command{mds-goback-save} is executed in the dead showstat buffer,
@pxref{Dead Showstat Buffer}, the goback point is set in the
corresponding procedure.

The goback point is overwritten when @command{mds-goto-procname},
@pxref{mds-goto-procname}, or @command{mds-here}, @pxref{mds-here}, are
called because they also save the goback point, to permit recovery.

@kindex p
@findex mds-showstop
@item p (@command{mds-showstop})
Showstop: display a list of all procedures containing breakpoints, all
watchpoints, and all error watchpoints.  Conditional breakpoints are
not included.

@kindex u
@findex mds-unstopat
@item u (@command{mds-unstopat})
Unstopat: Clear a breakpoint at the start of the statement at the cursor.

@end table

@node Watchpoints, Evaluation, Breakpoints, Showstat Mode
@subsection Watchpoints
@cindex watchpoints

A @emph{watchpoint} set on a variable causes the debugger to stop 
immediately following a statement that assigns a value to that variable.
A @emph{conditional watchpoint} is a watchpoint with an associated value;
the watchpoint is tripped when the variable is assigned that value.

Maple distinguishes two types of watchpoints: @emph{global} and @emph{local}.
Global watchpoints apply to global variables, local watchpoints to local variables.

@strong{Nota Bene:}
The Maple debugger has a bug; it does not properly handle watchpoints
for variables that are local to a module, or to a procedure of a module.
Attempting to set a local watchpoint on such a variable returns the error

@example
Error, global name or [proc name, local name] expected
@end example

As a workaround, set a global watchpoint on a module-local variable.
Note that a global watchpoint must be reset each time the procedure is debugged.

@table @asis

@kindex I
@findex mds-stopwhenif
@item I (@command{mds-stopwhenif})
stopwhenif:  Set a conditional watchpoint on the specified global variable.
The variable name and conditional value are entered separately in the mini-buffer.
Use @kbd{C-u W} to clear a conditional watchpoint.

@kindex p
@findex mds-showstop
@item p (@command{mds-showstop})
Showstop: display a list of all procedures containing breakpoints, all
watchpoints, and all error watchpoints.

@kindex w
@kindex C-u w
@findex mds-stopwhen-local
@item w (@command{mds-stopwhen-local})
stopwhen: Set a local watchpoint.   
The variable name is entered in the mini-buffer.
Use @kbd{C-u w} to clear a local watchpoint.


@kindex W
@findex mds-stopwhen-global
@item W (@command{mds-stopwhen-global})
stopwhen: Set a global watchpoint. 
The variable name is entered in the mini-buffer.
Use @kbd{C-u W} to clear a global watchpoint.



@end table


@node Evaluation, Miscellaneous, Watchpoints, Showstat Mode
@subsection Evaluation
@cindex evaluation, expression

MDS can evaluate expressions using the current context of Maple.

@table @asis

@kindex a
@findex mds-args
@item a (@command{mds-args})
Display the arguments of the current procedure as a vertical list of values.

@kindex A
@findex mds-show-args-as-equations
@item A (@command{mds-show-args-as-equations})
Display the arguments of the current procedure as a vertical list of equations.
The left-side of each equation is the formal parameter, 
the right-side is the value.

@kindex e
@kindex C-u e
@findex mds-eval-and-display-expr
@item e (@command{mds-eval-and-display-expr})
Evaluate an expression in the current context.
The expression is entered in the mini-buffer.  
The default expression is taken from the text at the cursor.
Use @kbd{C-u e} to return an expression of unlimited size.

@kindex E
@kindex C-u E
@findex mds-eval-and-display-expr-global
@item E (@command{mds-eval-and-display-expr-global})
Evaluate an expression in the global context.
The expression is entered in the mini-buffer.  
The default expression is taken from the text at the cursor.
Use @kbd{C-u E} to return an expression of unlimited size.

@kindex .
@kindex C-u .
@findex mds-eval-and-prettyprint
@item . (@command{mds-eval-and-prettyprint})
Evaluate an expression and prettyprint the result.
The pretty-printing depends on the type of the evaluated expression.
The first line of the display (after the echoing of the expression)
shows the type of the output, the remaining lines display the
expression in an expanded form.
Use @kbd{C-u .} to return an expression of unlimited size.

For a list or set, each element is displayed on a separate line.
For a record or table, each field/entry is displayed as an equation
with the index/field on the left, the entry on the right.

For example, the display of a record may appear as

@example
@anchor{prettyprint}
(*record*)
a = 23,
b = 12,
c = NULL
@end example

@kindex ,
@kindex C-u ,
@findex mds-eval-and-prettyprint-prev
@item , (@command{mds-eval-and-prettyprint-prev})
Works like @command{mds-eval-and-prettyprint} but uses expression at
the previous statement, that is, with a statement-number one 
less than the current statement.  
This command is useful for pretty-printing the last computation, 
but only when that is the result of the previous statement.
Use @kbd{C-u ,} to return an expression of unlimited size.

@end table

@node  Miscellaneous, Monitoring, Evaluation, Showstat Mode
@subsection Miscellaneous
@cindex miscellaneous

@table @asis

@kindex L
@findex mds-ss-refresh
@item L (@command{mds-ss-refresh})
Refresh the procedure.
This is frequently needed after patching a procedure
(@pxref{Patching}).
MDS does not automatically redraw a procedure upon entry,
that happens only if the name of the procedure has changed.

@kindex T
@findex mds-toggle-truncate-lines
@item T (@command{mds-toggle-truncate-lines})
Toggle the truncating/wrapping of long lines. 
With prefix argument (@kbd{C-u T}) do so in the @emph{debugger output buffer}.

@end table

@node Monitoring, Patching, Miscellaneous, Showstat Mode
@subsection Monitoring
@cindex monitoring

Arbitrary Maple expressions can be monitored.  The expressions
are evaluated at each step and the results displayed in
the @emph{debugger output buffer}.  A global monitor expression
can be assigned for all procedures; each procedure can also
have its own monitor expression.  Both types of expressions
are displayed.  The expressions are evaluated in the context
of the procedure.

@table @asis
@kindex m
@findex mds-monitor-toggle
@item m (@command{mds-monitor-toggle})
Toggle the monitoring operation.

@kindex M
@findex mds-monitor-define
@item M (@command{mds-monitor-define})
Define a monitor expression for the current procedure.
With prefix argument (@kbd{C-u M}) the monitor expression
applies to all procedure.  Both types of monitor expressions
can coexist.  The expression is queried in the minibuffer.

@end table

@node Patching, Help, Monitoring, Showstat Mode
@subsection Patching
@cindex patching

MDS can temporarily modify the procedure it is debugging.
This is an experimental feature---its operation is subject to change.
The following commands are currently assigned.

@table @asis
@kindex P
@findex mds-patch
@findex mds-patch-mode
@item P (@command{mds-patch})
Patch a procedure.  This is executed from the live showstat buffer.
It opens a buffer that contains a copy of the current procedure.
The name of the buffer is that of the procedure.
The buffer has major-mode @code{mds-patch-mode}, which is
a derivative of @code{maplev-mode}.  
@inforef{Top,,maplev}.
Edit this buffer as desired then execute @command{mds-patch-install}
to install the patch.

@kindex @kbd{C-c C-p}
@findex mds-patch-install
@item @kbd{C-c C-p} (@command{mds-patch-install})
Install the patch in the patch buffer.
This is executed from the patch buffer.

@end table

The following steps explain how to patch a procedure.

@enumerate
@item
Stop the debugger in the procedure to be patched.
@findex mds-patch
@item
Execute @command{mds-patch} (@kbd{P}).
This opens a buffer that contains a copy of the procedure.
@item
Edit the procedure.
@findex mds-patch-install
@item
Execute @command{mds-patch-install}
(@kbd{C-c C-p}, or use the @strong{Install} entry in the @strong{Patch} menu).
@item
Return to the Maple debugger showstat buffer.
@item 
Quit the debugger (@kbd{q}).
@item
Rerun the Maple code.
@end enumerate

You will usually have to re-instrument the procedure 
so that the debugger stops inside it.

If the patched procedure is local to a module, or accesses local variables/procedures of a module,
it may be necessary to execute, in Maple,
@code{kernelopts(opaquemodules=false)}
to permit the patched procedure to operate properly.

The patched procedure remains in effect until Maple is restarted.

In addition to temporarily modifying the normal execution of a procedure,
patching is also useful for enhancing debugging.  For example, 
you may insert a print statement to display an internal expression.
Inserting an explicit @code{DEBUG()} statement
inside a custom conditional to initiate debugging when particular conditions 
are met is another common use.


@node Help,  , Patching, Showstat Mode
@subsection Help
@cindex help

The MDS showstat-mode has several ways for obtaining help.


@table @asis

@kindex C-h m
@item C-h m
Display the help for this mode.

@kindex H
@findex mds-info
@item H (@command{mds-info})
Open the @command{info} document for MDS mode (this document).

@kindex C-?
@findex maplev-help-at-point
@item C-? (@command{maplev-help-at-point})
Display a Maple help page.  The topic is entered in the mini-buffer,
with the default the word under the cursor.

@kindex M-?
@findex maplev-proc-at-point
@item M-? (@command{maplev-proc-at-point})
Display a Maple procedure.  The procedure name is entered in the mini-buffer,
with the default the word under then cursor.

@end table

@node LineInfo Buffer, Output Buffer, Showstat Buffer, Top
@chapter LineInfo Buffer
@cindex lineinfo buffer

The line-info buffer displays the source file of the 
current Maple procedure during debugging.  An arrow in the
left margin points to the current line in the procedure.

This mode uses an undocumented, experimental feature introduced in Maple 16.
As such, there are a few limitations with using it.

@menu
* Accessing LineInfo::          Creating the line-info data.
* LineInfo Mode::               Available commands.
* LineInfo Caveats::            Limitations.
@end menu

@node Accessing LineInfo, LineInfo Mode, LineInfo Buffer, LineInfo Buffer
@section Accessing LineInfo
@cindex Accessing LineInfo

The line-info buffer is active whenever line-info data is available for
a procedure.  Line-info data is available when a Maple source file
is read into Maple, either with the Maple @code{read} command, or by
passing the file as input to tty Maple.  Using an absolute path to the
filename, or include files, may be necessary to permit access to the
data while changing directories during code execution.  

The line-info data stores the location of the source file relative to
the current directory.  If the code being debugged changes current
directory, the line-info source file may become inaccessible, in which
case the debugger switches to the showstat buffer (interpreted
code-view).  To avoid this, use an absolute path to the source file.


@node  LineInfo Mode, LineInfo Caveats, Accessing LineInfo, LineInfo Buffer
@section LineInfo Mode
@cindex LineInfo Mode

The line-info buffer has the major mode @code{mds-li-mode},
which binds the same keys as @code{mds-showstat-mode}
to equivalent commands; see @ref{Showstat Mode}.
In addition, it provides the following commands:

@table @asis

@kindex v
@findex mds-wm-toggle-code-view
@item v (@command{mds-wm-toggle-code-view})

Toggle the code-view between the interpreted-code (showstat-live buffer)
and source-code (line-info buffer).
This command (and key) can be used in the showstat-live buffer to return
to the line-info buffer.

Toggling is useful to verify that source-code has been interpreted properly.
There are a few constructs that currently are not handled by the line-info
feature; @ref{LineInfo Caveats}.


@kindex G
@findex mds-li-open-source-at-point
@item G (@command{mds-li-open-source-at-point})

Open the file associated with current procedure.

@end table

@node LineInfo Caveats,  , LineInfo Mode, LineInfo Buffer
@section LineInfo Caveats
@cindex LineInfo Caveats

There are a few known bugs with the line-info feature.

@menu
* Preprocessor macros::         Avoid multi-statement macros.
* for-less do-loops::           A glitch with while loops.
* use statement::               Use @code{uses}.
* Declaration Self-Assignment::  Avoid this undocumented feature.
@end menu

@node  Preprocessor macros, for-less do-loops, LineInfo Caveats, LineInfo Caveats
@subsection Preprocessor macros
@cindex Preprocessor macros

Preprocessor macro definitions that expand to more than one Maple statement
are not handled properly.  Avoid these when writing Maple source code.
For example, 

@example
$define CB  "cbSignalStrength"                # this is okay
$define IF(x) if x<0 then 1 else 2 end if     # this is not
@end example


@node for-less do-loops, use statement, Preprocessor macros, LineInfo Caveats
@subsection for-less do-loops
@cindex for-less do-loops

A @strong{for}-less @strong{do}-loop does not store the data for the @strong{do}
statement.  This causes the debugger to automatically switch to the
showstat buffer when the current statement is the @strong{do} statement.
The debugger switches back to the lineinfo buffer when the @strong{do}
statement is no longer active.

For an example, see the following code.  When the cursor reaches the
marked statement, the debugger switches to the showstat buffer.  If an
@strong{into} debugger command is then executed, the assignment
statement, @code{x[i] := i+1}, becomes the active statement and the
debugger switches back to the line-info buffer.

@example
@anchor{do-loop}
@iftex
    i := 1;
=>  @strong{while} i < 5 @strong{do}
        x[i] := i+1;
    @strong{end do};
@end iftex
@ifinfo
    i := 1;
=>  while i < 5 do
        x[i] := i+1;
    end do;
@end ifinfo
@end example

@node use statement, Declaration Self-Assignment, for-less do-loops, LineInfo Caveats
@subsection use statement
@cindex use statement

The line-info data generated for a procedure
with a @strong{use}-statement is incorrect.
Use the @strong{uses} statement instead.

For example, instead of 

@example
f := proc(M :: Matrix, X :: Vector)
local V;
    use LA = LinearAlgebra in
        V := LA:-LinearSolve(A,X);
    end use;
end proc;
@end example

@noindent do this.

@example
f := proc(M :: Matrix, X :: Vector)
local V;
uses LA = LinearAlgebra;
    V := LA:-LinearSolve(A,X);
end proc;
@end example

@node Declaration Self-Assignment,  , use statement, LineInfo Caveats
@subsection Declaration Self-Assignment

Maple 16 has an undocumented feature such that if, in a local
declaration, a variable is assigned to itself, the assignment is removed
from the interpreted procedure.  The purpose of this is prevent a mint
warning of an unused variable if the variable is not assigned in the
procedure body; this frequently happens with an index to a @code{seq}
procedure.  For example, one might do

@example @asis
@iftex
f := @strong{proc}(X)
@strong{local} x := x; # dummy assignment to avoid mint nag
    seq(x, x = X);
@strong{end proc};
@end iftex
@ifinfo
f := proc(X)
local x := x; # dummy assignment to avoid mint nag
    seq(x, x = X);
end proc;
@end ifinfo
@end example

This is interpreted by Maple as

@example @asis
@iftex
f := @strong{proc}(X)
@strong{local} x; # note the assignment is removed
    seq(x, x = X);
@strong{end proc};
@end iftex
@ifinfo
f := proc(X)
local x;
    seq(x, x = X);
end proc;
@end ifinfo
@end example

The line-info data for such a procedure is incorrect.  To avoid this, do
not use this feature in your source code.  If debugging a Maple procedure
that uses this, switch to viewing interpreted code.

To avoid a mint warning without using this feature, use a preprocessor
conditional that is enabled only during mint, say by assigning the
preprocessor variable @code{MINT_ONLY} in the mint resource file
(@file{.mintrc}).  For example,

@example @asis
@iftex
f := @strong{proc}(X)
@strong{local} x;
$ifdef MINT_ONLY
    x := NULL;
$endif
    seq(x, x = X);
@strong{end proc};
@end iftex
@ifinfo
f := proc(X)
local x;
$ifdef MINT_ONLY
    x := NULL;
$endif
    seq(x, x = X);
end proc;
@end ifinfo
@end example


@node Output Buffer, Debugging Tips, LineInfo Buffer, Top
@chapter Output Buffer
@cindex output buffer


The output buffer displays Maple output during debugging.  It also echos
the user input, and optionally, the input statements executed.

The following is representative of the output buffer content

@example
@b{fibonacci}
(*1*) into    @b{if} i < 1 
32
(*2*) 
@end example

The line ``@b{fibonacci}'' is the name of the procedure that is being debugged.
Whenever a procedure is entered, the name of it is printed in the output buffer.
The name is hyperlinked; clicking on it (mouse-1) displays the procedure
in the showstat dead buffer.

@vindex mds-track-input-flag
@findex mds-toggle-track-input
Debugger commands that evaluate program code are echoed in the buffer.
If the @code{mds-track-input-flag} variable is non-nil, 
the corresponding statement is printed after the debugger command.  
This provides a visual trace of the commands executed.
Use @command{mds-toggle-track-input} to toggle the variable.

Right-clicking (mouse-3) in the output buffer displays, in the showstat-dead
buffer, the procedure at the appropriate statement that generated that output.

@menu
* Output buffer commands::      
@end menu

@node  Output buffer commands,  , Output Buffer, Output Buffer
@section Output buffer commands

@findex mds-out-write-buffer
The @command{mds-out-write-buffer} command writes the output buffer
to a specified file.  Unlike @command{write-file}, the buffer name
does not change.



@node  Debugging Tips, Key Index, Output Buffer, Top
@chapter Debugging Tips
@cindex debugging tips

@menu
* Set breakpoint in calling procedure::  Locating a bug.
* Locate source of unexpected result::  Finding where an expression originates.
* Assign a variable::           Returning intermediate results to Maple.
* Save a local result::         Saving intermediate results to a file.
@end menu

@node Set breakpoint in calling procedure, Locate source of unexpected result, Debugging Tips, Debugging Tips
@section Set breakpoint in calling procedure
@cindex Set breakpoint in calling procedure

After using @command{stoperror} to stop the debugger at the location of
an error, you realize that the real problem lies in an ``upstream''
procedure.  To debug it, you want to set a breakpoint in that procedure.

@enumerate
@item
Use the @command{mds-where} command (@kbd{K}) to display the
stack contents in the output buffer.

@item
Click on the relevant calling procedure.  The procedure is
displayed in the showstat-dead buffer

@item
In the showstat-dead buffer, set a breakpoint at an appropriate
statement in the calling procedure.  Do this by putting the cursor
on the appropriate statement and executing @command{mds-breakpoint} (@kbd{b}).

@item
Quit the debugger (@kbd{q}) and re-execute the code in Maple.  
The debugger will halt in the procedure of interest.

@end enumerate

@node  Locate source of unexpected result, Assign a variable, Set breakpoint in calling procedure, Debugging Tips
@section Locate source of unexpected result
@cindex Locate source of unexpected result

A computation gives the wrong result, but it is not apparent which
procedure, or what line of code, is the culprit. 
There are a couple ways to handle this.

One possibility is to use the tracing feature, possibly with
the @code{step} option; @pxref{tracing}.
A disadvantage with tracing is
that it produces a lot of output and is slow.

Frequently a better way is to use @emph{skipping}.
Call @code{mdc} with the @code{skip_until} option, or
call @code{mdc:-SkipUntil} directly to assign a predicate
that skips code until a condition is met.
See the examples in the @code{mdc[SkipUntil]} help page, in Maple.
With a predicate assigned, skip to the condition by typing
@kbd{S} in the showstat buffer.

@node Assign a variable, Save a local result, Locate source of unexpected result, Debugging Tips
@section Assign a variable
@cindex Assign a variable

To assign to a Maple variable, evaluate an assignment statement using
the command @command{mds-eval-and-display-expr}, which is mapped to the
@kbd{e} key.  For example, @kbd{e x := 1 @key{RET}} assigns 1 to the
variable @code{x}.  If @code{x} is a local variable, the local variable
is reassigned; this is useful for temporarily altering the operation of
a procedure.  If @code{x} is not a local variable, a global variable is
assigned; this is useful for making an internal value available for
further manipulation after exiting the debugger.

To assign the value of a local variable to a global variable with the
same name, use the Maple @command{assign} procedure; for example,
evaluate @code{assign(:-x,x)} to assign the value of the local variable
@code{x} to the global variable @code{:-x}.

@node Save a local result,  , Assign a variable, Debugging Tips
@section Save a local result
@cindex Save a local result

While debugging, it is frequently useful to save a local result to an
external file so that it can be manipulated afterwards.
One way to do this is to first save the result to a global
variable, @ref{Assign a variable}, then save the global
to a file by evaluating the Maple @code{save} statement in a global
context, using @code{mds-eval-and-display-expr-global},
which is mapped to the @kbd{E} key.

For example, to save the value of the local variable @code{x}
to the file @file{/tmp/x.mpl}, do

@example @asis
e assign(:-x,x) @key{RET}
E save x, "/tmp/x.mpl" @key{RET}
@end example

File @file{/tmp/x.mpl} contains an assignment to the variable @code{x}.


@node Key Index, Function Index, Debugging Tips, Top
@unnumbered Key Index
@printindex ky

@node Function Index, Variable Index, Key Index, Top
@unnumbered Function Index
@printindex fn

@node Variable Index, Concept Index, Function Index, Top
@unnumbered Variable Index
@printindex vr

@node Concept Index, GNU Free Documentation License, Variable Index, Top
@unnumbered Concept Index
@printindex cp

@node GNU Free Documentation License,  , Concept Index, Top
@appendix GNU Free Documentation License
@include fdl.texi

@summarycontents
@bye
